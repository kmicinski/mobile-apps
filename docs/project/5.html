<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Projects 3I and G: Web Frameworks and Security</title>
  <meta name="description" content="This project will have you launch some exploits against an insecureweb app and implement a (hopefully secure) web frontend for your chatserver. This project ...">

  <link rel="stylesheet" href="http://localhost:4000/css/main.css">
  <link rel="canonical" href="http://localhost:4000/project/5">
  <link rel="alternate" type="application/rss+xml" title="CS107" href="http://localhost:4000/feed.xml">
</head>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href=http://localhost:4000/>CS107</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
          <a class="page-link" href="http://localhost:4000/assignments/">Assignments</a>
          
        
          
          <a class="page-link" href="http://localhost:4000/blog/">Posts</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="http://localhost:4000/resources">Resources</a>
          
        
          
          <a class="page-link" href="http://localhost:4000/schedule/">Schedule</a>
          
        
          
          <a class="page-link" href="http://localhost:4000/syllabus/">Syllabus</a>
          
        
      </div>
    </nav>

  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Projects 3I and G: Web Frameworks and Security</h1>
    <h3><b>Project due date: <time datetime="2018-04-23T00:00:00-04:00">Apr 23,
    2018 (5:59PM Eastern)</time></b></h3>
  </header>

  <div class="post-content writeup-content" itemprop="articleBody">
    <p>This project will have you launch some exploits against an insecure
web app and implement a (hopefully secure) web frontend for your chat
server. This project will be the end of our semester, after which
we’ll start breaking each others’ assignments! So make it a good one
:-)</p>

<p>This portion of the project is individual and group work. Each portion
is clearly marked. During the course of this project you are allowed
access to all online resources, but you are required to cite any
resource that gave you any significant insight into the project,
including conversations you had with your classmates. You will put
these sources in <code class="highlighter-rouge">SOURCES.md</code> within this folder. The project is
clearly separated into attacks (individual) and implementation. The
individual and group assignments will have separate github repos.</p>

<p>Please respect the department’s collaboration policy. Specifically,
you are not allowed to look at any other student’s <em>code</em> (or do
anything equivalent, such as talking through your code on a
line-by-line basis). You may discuss pseudo-code on the board, but
afterwards you must erase it (so as to not let anyone else see it) and
then cite your conversation with the other person in a comment in your
code (and in the sources file).</p>

<h1 id="individual-portion-attacks--defenses">Individual Portion: Attacks / Defenses</h1>

<p>For the individual portion of this assignment, you’ll write a set of
exploits using either
<a href="http://selenium-python.readthedocs.io/">Selenium</a> or
<a href="https://docs.python.org/3/howto/urllib2.html">urllib</a>. Both of these
libraries allow you to programmatically interact with webpages, and I
highly recommend you learn a little bit about them before attempting
too much of this project.</p>

<h2 id="about-the-app">About the App</h2>

<p>The vulnerable webapp I’ve given you is available through Github
Classroom. Please clone it through that interface. For everyone else
following along, it’s at:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://github.com/kmicinski/project-3-starter
</code></pre></div></div>

<p>You can run it by first setting up the database:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python app.py init
</code></pre></div></div>

<p>And then booting up the app:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python app.py
</code></pre></div></div>

<p>Which will then launch the app on your local machine.  Note that you
may need to <code class="highlighter-rouge">pip install</code> a few things before running the app,
including (at least) flask.</p>

<h3 id="part-1-sql-injection-attacks-20-points">Part 1: SQL Injection Attacks [20 points]</h3>

<p>For this part of the project, I want to show how you can log in as any
desired user. You should write a script <code class="highlighter-rouge">execute_sqli.py</code> that takes
one command-line parameter: the user for which you want to log
in. Your script must then find a way to log into the server by
exploiting an SQL injection in the vulnerable app, and then post a
chat from that user which says “I wish I were a squirrel.”</p>

<p>Deliverable: <code class="highlighter-rouge">execute_sqli.py</code>, which launches the vulnerability
described above.</p>

<h3 id="part-2-cross-site-request-forgery-10-points">Part 2: Cross-Site Request Forgery [10 points]</h3>

<p>The answer to this part of the project is a link. In the web
application, there is an instance of Cross-Site request forgery that
allows me to change the password of whatever user I’m logged in
as. Show me where it is, and give me an example link showing how I’d
exploit it to change the user’s password.</p>

<p>By the way, you should read up on why <a href="https://security.stackexchange.com/questions/147188/is-it-bad-practice-to-use-get-method-as-login-username-password-for-administrato">GET requests should not be used
for this kind of
thing</a>. Basically,
the user’s browser will cache these kinds of requests in history,
which is relatively insecure, and GET requests are straightforward to
turn into clickable links. By contrast, you can’t POST data via a
link.</p>

<p>Deliverable: a link that the user can click such that–when
clicked–it will launch an XSRF attack and change the user’s password.</p>

<h3 id="part-3-xss-30-points">Part 3: XSS [30 points]</h3>

<p>This part requires writing your own small webapp to request and store
passwords.</p>

<p>Your goal in this part is to exploit a cross-site scripting
vulnerability in the webapp. Notice that none of the data passed in
for the chat messages is validated or scrubbed in any way. Therefore,
it is trivial to pass in a script that will execute on anyone’s
browser when they pull up the chat window. For example, if you type in
<code class="highlighter-rouge">&lt;script&gt;alert(1)&lt;/script&gt;</code>, instead of showing you a chat message,
your browser will display an alert to you.</p>

<p>Exploit this vulnerability to launch an XSS vulnerability that sends
the user’s password to your webapp and stores a list of passwords
collected. To do this, you should write a small web service yourself
that hosts a static script containing the code you want to inject into
the user’s browser. Your attack script should then insert some code
like <code class="highlighter-rouge">&lt;script src=localhost:8700/myscript.js&gt;&lt;/script&gt;</code>, which will
then load your script from <code class="highlighter-rouge">localhost:8700</code> and perform the right
commands to launch the attack. Finally, you must show me that your web
app can store the passwords in some way.</p>

<p>Deliverable: A directory <code class="highlighter-rouge">xss_attack_server</code> that hosts your web app,
which will act to host the static script itself. (Here’s <a href="https://stackoverflow.com/questions/20646822/how-to-serve-static-files-in-flask">some starter
code</a>
to host static files from Flask!). This web app should have some way
to store the passwords, e.g., a file on disc, an SQLite database,
etc.. It should also have some easy way for me to view retrieved
passwords. You must <em>also</em> include a file <code class="highlighter-rouge">inject_xss.js</code> that logs in
as some specified username / password to the server and actually
launches the attack.</p>

<h3 id="part-4-defenses-against-sqli-and-xss-10-points">Part 4: Defenses against SQLi and XSS [10 points]</h3>

<p>In this part, you’ll eliminate a few of the attacks you just
performed.</p>

<ul>
  <li>
    <p>[5 points] Completely eliminate the SQLi attacks performed here
using, e.g., prepared statements (some of the server is using them
already).</p>
  </li>
  <li>
    <p>[5 points] Properly escape data incoming from the client to
eliminate the XSS attack described in Part 3:
http://flask.pocoo.org/docs/0.12/security/#cross-site-scripting-xss</p>
  </li>
</ul>

<p>Deliverable: <code class="highlighter-rouge">app_fixed.py</code> that includes these two fixes.</p>

<h1 id="group-portion-implementation">Group Portion: Implementation</h1>

<p>For this portion of the assignment, you will complete our chat server
by building a web frontend for the server. The web frontend will offer
the following functionality:</p>

<ul>
  <li>
    <p>Creating new accounts</p>
  </li>
  <li>
    <p>Allowing users to change passwords on existing accounts</p>
  </li>
  <li>Allowing the user to view logs of channels that haven’t been
encrypted (and from which they haven’t been banned):
    <ul>
      <li>Users should be able to log in and see the list of available
channels hosted on the server</li>
      <li>Users should be able to see the channel topic</li>
      <li>They should also see the list of files available on the channel,
including the file name and file size. If they have the correct
privileges (either the person who uploaded it or the channel
admin) they should be able to delete it.</li>
      <li>Users should be able to <em>download</em> the files from the server.</li>
      <li>Users should be able to <em>upload</em> files to the server.</li>
    </ul>
  </li>
  <li>
    <p>Allowing users to manage their block lists, blocking and unblocking
other users.</p>
  </li>
  <li>Allowing channel administrators to perform various operations on
channels:
    <ul>
      <li>Give other users administration privileges</li>
      <li>Change the channel topic</li>
      <li>Ban users from channels</li>
    </ul>
  </li>
</ul>

<h2 id="design-details">Design Details</h2>

<p>You should implement your web frontend using some web framework,
though I do not care which. If you have implemented the previous parts
of projects 1G and 2G correctly, you should leverage your
implementation in those parts to complete 3G. Specifically, you should
have your server set up so that you run the web server using flask,
and run the chat server alongside that web server, but on a
<em>different</em> port. I would specifically recommend either using Flask or
Django for this project.</p>

<p>Note that you will need some way for the web frontend and the chat
server to agree on some amount of the data. For example, they both
need to be able to read logs of channels for various users. You have a
few options for how to go about this: you could set up the web
frontend so that it talked to the chat server by sending packets
according to the protocol, for instance. But that’s not a very robust
design. A better design–and the one I recommend–is to have your chat
server and web server both share some database implemented using an
SQL server (SQLite is fine for this project).</p>

<p>For example, you may want to restructure your chat server so that it
keeps the password database as an SQL table. In the web interface, you
should have a form that allows the user to create a new account
and–if its not in the table–salts and hashes it using the <em>same
exact</em> mechanism you use from project 2G. I recommend having a shared
set of library code (i.e., helper functions you use in both codebases)
between the client and server to make this easier. Then, in the chat
server, when a connection is received and an authenticate command is
executed, check for the password in that SQLite table.</p>

<p>Similar modifications will need to be made with other commands.</p>

<p>If you do choose to base your implementation off the horribly-insecure
example app I’ve written, you should absolutely read the documentation
for Flask for a while before just brazenly charging along and copying
the bad coding style there. Specifically, reconnecting to the DB every
time is silly and terrible form done for illustrative purposes of
writing a crummy exploitable app. Instead, for example, read <a href="http://flask.pocoo.org/docs/0.12/patterns/sqlite3/">this
page</a> on using
SQLite with Flask. Similar tutorials exist for PostgreSQL and MySQL.</p>

<h2 id="scoring-breakdown">Scoring Breakdown</h2>

<p>Your server should include at least the following:</p>

<ul>
  <li>
    <p>[10 points] You have <em>some</em> webservice that runs alongside your chat
server. This is the bare minimum you can do, and I recommend
tackling this part first. The way to start with this is to take the
example code I’ve given out for the Flask attacks and then run your
chat server alongside it.</p>
  </li>
  <li>
    <p>[10 points] The web app must run via HTTPS with some
certificate. It’s okay if this certificate is self-signed, though
(you won’t be able to get a “real” certificate, because you’ll just
be running the app on your own browser and won’t be able to anchor
it to a specific domain).</p>
  </li>
  <li>
    <p>[15 points] The ability to log in and create an account on the
server. This infrastructure works alongside the infrastructure used
in your chat server.</p>
  </li>
  <li>
    <p>[10 points] The ability for users to change their passwords once
logged in.</p>
  </li>
  <li>
    <p>[15 points] After users are logged in, they should see a page that
allows them see all of the channels on the server from which they
are not banned. Channels of which they are the administrator should
be designated in some special way (e.g., with an “A” letter before
the name, or colored green, or something like that). In particular,
they should <em>not</em> see channels from which they have been banned.</p>
  </li>
  <li>
    <p>[5 points] Users should be able to create new channels from the main
screen.</p>
  </li>
  <li>
    <p>[10 points] Each channel should have a screen in the app which is
viewable by anyone who has not been banned from the channel. This
screen should show the log of chats on the channel, up to the 500
most recent messages. This screen should also list the files
associated with the channel.</p>
  </li>
  <li>
    <p>[5 points] Users should be able to download files associated with a
channel from this screen.</p>
  </li>
  <li>
    <p>[5 points] Users should be able to <em>upload</em> files associated with
the channel from this screen.</p>
  </li>
  <li>
    <p>[5 points] Administrators on this channel should have the option to
change the channel topic, as well as give administration privileges
to other users. These privileges should be reflected in the client.</p>
  </li>
  <li>
    <p>[5 points] Administrators should be able to ban users on channels of
which they are administrators.</p>
  </li>
  <li>
    <p>[10 points] Write a design document of at least four thoughtful
paragraphs describing various security issues you thought over while
designing your server. The kinds of questions you’ve been asking on
Piazza, and the kinds of questions you’ve asked to each other in
person, are the kinds of things you want to discuss here. For
example, how did you make sure to avoid SQL injection and cross-site
scripting attacks? This can be as broad or narrow as you want, as
long as it’s thoughtful and covers the security-relevant problems
you tackled while working on the project.</p>
  </li>
</ul>

<p>Note that you must be especially careful to make sure that changes
made on the server are <em>reflected</em> in the client. For example, if
someone is banned from a channel in the webapp, they should similarly
be kicked from the channel if they are logged in on the web
server. This is probably the trickiest part of the assignment, and
you’ll have to be careful about how you implement it.</p>

<p>Note that various parts of 2G make things encrypted in various
ways. You’ll have to use your head here: it doesn’t make any sense to
show logs for encrypted channels, for example, because the server
won’t have the keys to decrypt them. If you did this, you should also
have some “public channels” that allow their logs to be viewable
without crypto, too.</p>

<p>There is no need to show private messages on the web interface. In an
ideal world, you would write a web app that allowed the client to
decrypt the conversation: i.e., JavaScript code that hands the
conversation to your client, uses the client’s secret key (stored in
the browser, but never escaping it) to decrypt messages, etc.. But in
practice this is quite complicated: browsers don’t make it easy to
manage keys and access local files, for example. Therefore, for this
project, you can feel free to ignore anything that would require you
to load a secret key from the client’s browser. However, all of that
should still work on your <em>client</em> that you implemented for 2G.</p>

<p>This part of the project is meant to be challenging, so make sure you
start early and think through a good design for the server, paying
particular caution to how you’ll ensure your client from 2G still
works with the chat server you’re implementing.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    

    <!-- <h2 class="footer-heading">CS107</h2> -->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>CS107</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>CS107</p>
      </div>
    </div>

  </div>

</footer>

<script src=http://localhost:4000/bower_components/jquery/dist/jquery.min.js></script>
<script src=http://localhost:4000/bower_components/bootstrap-sass/assets/javascripts/bootstrap.min.js></script>


  </body>

</html>
